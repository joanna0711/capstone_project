{"ast":null,"code":"var _jsxFileName = \"/Users/song-wonjeong/Desktop/react-python/workspace/src/components/Skills/WebcamComponent.js\",\n    _s = $RefreshSig$();\n\nimport React, { useRef, useEffect, useCallback } from 'react';\nimport Webcam from 'react-webcam';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst WebcamApp = _ref => {\n  _s();\n\n  let {\n    selectedObject,\n    objectCount,\n    shootingInterval\n  } = _ref;\n  // 웹캠 참조 객체를 생성합니다.\n  const webcamRef = useRef(null);\n  useEffect(() => {\n    // 웹캠에 대한 제약사항(constraints)을 정의합니다.\n    const constraints = {\n      video: true\n    }; // 웹캠에 접근하여 스트림을 받아옵니다.\n\n    navigator.mediaDevices.getUserMedia(constraints).then(stream => {\n      // 웹캠 컴포넌트의 스트림에 연결합니다.\n      webcamRef.current.stream = stream;\n    }).catch(error => {\n      console.error('웹캠 접근 에러: ' + error);\n    });\n  }, []); // 이미지를 저장하는 함수를 생성합니다.\n\n  const saveImageFunction = useCallback(() => {\n    const link = document.createElement('a');\n    link.href = webcamRef.current.getScreenshot();\n    link.download = `capture_${Date.now()}.jpg`;\n    link.click();\n  }, [webcamRef]); // 이미지를 서버로 전송하는 함수를 생성합니다.\n\n  const sendImageToServer = useCallback(async () => {\n    if (!webcamRef.current) {\n      return;\n    } // 웹캠으로부터 이미지 스크린샷을 가져옵니다.\n\n\n    const imageSrc = webcamRef.current.getScreenshot(); // FormData를 사용하여 이미지를 포함시킵니다.\n\n    const formData = new FormData();\n    formData.append('image', imageSrc);\n\n    try {\n      // 서버에 이미지를 POST로 전송합니다.\n      let response = await fetch(\"http://localhost:8000/detect\", {\n        method: \"POST\",\n        body: formData\n      }); // 서버에서 응답 데이터를 JSON 형식으로 파싱합니다.\n\n      let data = await response.json(); // 감지된 객체 목록을 가져옵니다.\n\n      const detectedObjects = data.detected_objects; // 선택된 객체와 객체 수를 비교하여 이미지 저장 함수를 호출합니다.\n\n      const objectOccurrences = detectedObjects.filter(obj => obj === selectedObject).length;\n\n      if (objectOccurrences >= objectCount) {\n        saveImageFunction();\n      }\n    } catch (error) {\n      console.error(\"서버로 이미지 전송 에러: \", error);\n    }\n  }, [selectedObject, objectCount, saveImageFunction]);\n  useEffect(() => {\n    // 주기적으로 이미지를 서버로 전송하는 인터벌을 설정합니다.\n    const interval = setInterval(() => {\n      sendImageToServer();\n    }, shootingInterval * 1000); // 컴포넌트가 언마운트될 때 인터벌을 클리어합니다.\n\n    return () => clearInterval(interval);\n  }, [shootingInterval, sendImageToServer]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(Webcam, {\n      ref: webcamRef,\n      screenshotFormat: \"image/jpeg\",\n      videoConstraints: {\n        deviceId: 0\n      },\n      width: 500,\n      height: \"auto\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 79,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 77,\n    columnNumber: 9\n  }, this);\n};\n\n_s(WebcamApp, \"X6BqDEb7RUGMW2ox8W7PN5tPRWw=\");\n\n_c = WebcamApp;\nexport default WebcamApp;\n\nvar _c;\n\n$RefreshReg$(_c, \"WebcamApp\");","map":{"version":3,"sources":["/Users/song-wonjeong/Desktop/react-python/workspace/src/components/Skills/WebcamComponent.js"],"names":["React","useRef","useEffect","useCallback","Webcam","WebcamApp","selectedObject","objectCount","shootingInterval","webcamRef","constraints","video","navigator","mediaDevices","getUserMedia","then","stream","current","catch","error","console","saveImageFunction","link","document","createElement","href","getScreenshot","download","Date","now","click","sendImageToServer","imageSrc","formData","FormData","append","response","fetch","method","body","data","json","detectedObjects","detected_objects","objectOccurrences","filter","obj","length","interval","setInterval","clearInterval","deviceId"],"mappings":"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","sourcesContent":["import React, { useRef, useEffect, useCallback } from 'react';\r\nimport Webcam from 'react-webcam';\r\n\r\nconst WebcamApp = ({ selectedObject, objectCount, shootingInterval }) => {\r\n    // 웹캠 참조 객체를 생성합니다.\r\n    const webcamRef = useRef(null);\r\n\r\n    useEffect(() => {\r\n        // 웹캠에 대한 제약사항(constraints)을 정의합니다.\r\n        const constraints = { video: true };\r\n\r\n        // 웹캠에 접근하여 스트림을 받아옵니다.\r\n        navigator.mediaDevices.getUserMedia(constraints)\r\n        .then((stream) => {\r\n            // 웹캠 컴포넌트의 스트림에 연결합니다.\r\n            webcamRef.current.stream = stream;\r\n        }).catch((error) => {\r\n            console.error('웹캠 접근 에러: ' + error);\r\n        });\r\n    }, []);\r\n\r\n    // 이미지를 저장하는 함수를 생성합니다.\r\n    const saveImageFunction = useCallback(() => {\r\n        const link = document.createElement('a');\r\n        link.href = webcamRef.current.getScreenshot();\r\n        link.download = `capture_${Date.now()}.jpg`;\r\n        link.click();\r\n    }, [webcamRef]);\r\n\r\n    // 이미지를 서버로 전송하는 함수를 생성합니다.\r\n    const sendImageToServer = useCallback(async () => {\r\n        if (!webcamRef.current) {\r\n            return;\r\n        }\r\n\r\n        // 웹캠으로부터 이미지 스크린샷을 가져옵니다.\r\n        const imageSrc = webcamRef.current.getScreenshot();\r\n\r\n        // FormData를 사용하여 이미지를 포함시킵니다.\r\n        const formData = new FormData();\r\n        formData.append('image', imageSrc);\r\n\r\n        try {\r\n            // 서버에 이미지를 POST로 전송합니다.\r\n            let response = await fetch(\"http://localhost:8000/detect\", {\r\n                method: \"POST\",\r\n                body: formData\r\n            });\r\n\r\n            // 서버에서 응답 데이터를 JSON 형식으로 파싱합니다.\r\n            let data = await response.json();\r\n\r\n            // 감지된 객체 목록을 가져옵니다.\r\n            const detectedObjects = data.detected_objects;\r\n\r\n            // 선택된 객체와 객체 수를 비교하여 이미지 저장 함수를 호출합니다.\r\n            const objectOccurrences = detectedObjects.filter(obj => obj === selectedObject).length;\r\n            if (objectOccurrences >= objectCount) {\r\n                saveImageFunction();\r\n            }\r\n        } catch (error) {\r\n            console.error(\"서버로 이미지 전송 에러: \", error);\r\n        }\r\n    }, [selectedObject, objectCount, saveImageFunction]);\r\n\r\n    useEffect(() => {\r\n        // 주기적으로 이미지를 서버로 전송하는 인터벌을 설정합니다.\r\n        const interval = setInterval(() => {\r\n            sendImageToServer();\r\n        }, shootingInterval * 1000);\r\n\r\n        // 컴포넌트가 언마운트될 때 인터벌을 클리어합니다.\r\n        return () => clearInterval(interval);\r\n    }, [shootingInterval, sendImageToServer]);\r\n\r\n    return (\r\n        <div>\r\n            {/* 웹캠 컴포넌트를 렌더링합니다. */}\r\n            <Webcam\r\n                ref={webcamRef}\r\n                screenshotFormat=\"image/jpeg\"\r\n                videoConstraints={{ deviceId: 0 }}\r\n                width={500}\r\n                height=\"auto\"\r\n            />\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default WebcamApp;\r\n"]},"metadata":{},"sourceType":"module"}