{"ast":null,"code":"var _jsxFileName = \"/Users/song-wonjeong/Desktop/react-python/workspace/src/components/Skills/index.js\",\n    _s = $RefreshSig$();\n\nimport React, { useRef, useEffect, useCallback, useState } from 'react';\nimport Webcam from 'react-webcam'; // 웹캠 앱 컴포넌트\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction WebcamApp(_ref) {\n  _s();\n\n  let {\n    selectedObject,\n    objectCount,\n    shootingInterval,\n    detectionMode\n  } = _ref;\n  // 웹캠 참조 설정\n  const webcamRef = useRef(null); // 촬영 상태 표시 (빨간색: 촬영 중, 초록색: 촬영 완료)\n\n  const [indicatorColor, setIndicatorColor] = useState('red'); // 인터넷 연결 상태 확인\n\n  const [isOnline, setIsOnline] = useState(navigator.onLine); // 감지된 객체 수\n\n  const [detectedCount, setDetectedCount] = useState(0); // 서버 요청 진행 상태\n\n  const [isRequestInProgress, setIsRequestInProgress] = useState(false); // 이미지 저장 함수\n\n  const saveImageFunction = useCallback(() => {\n    const link = document.createElement('a');\n    link.href = webcamRef.current.getScreenshot();\n    link.download = `capture_${Date.now()}.jpg`;\n    link.click();\n  }, [webcamRef]); // 서버에 이미지 전송 및 객체 감지 함수\n\n  const sendImageToServer = useCallback(async () => {\n    if (!webcamRef.current || isRequestInProgress) {\n      return;\n    }\n\n    const imageSrc = webcamRef.current.getScreenshot();\n\n    if (!imageSrc) {\n      return;\n    }\n\n    setIsRequestInProgress(true);\n    const formData = new FormData();\n    formData.append('image', imageSrc);\n\n    try {\n      let response = await fetch(\"http://localhost:8000/detect\", {\n        method: \"POST\",\n        body: formData\n      });\n      let data = await response.json();\n      const detectedObjects = data.detected_objects;\n      const objectOccurrences = detectedObjects.filter(obj => obj === selectedObject).length;\n      setDetectedCount(objectOccurrences); // 감지 모드에 따른 이미지 저장 조건\n\n      if (detectionMode === \"above\" && objectOccurrences >= objectCount) {\n        saveImageFunction();\n        setIndicatorColor('green');\n      } else if (detectionMode === \"below\" && objectOccurrences <= objectCount) {\n        saveImageFunction();\n        setIndicatorColor('green');\n      } else if (detectionMode === \"fix\" && objectOccurrences === objectCount) {\n        saveImageFunction();\n        setIndicatorColor('green');\n      } else {\n        setIndicatorColor('red');\n      }\n    } catch (error) {\n      console.error(\"Error sending image to server: \", error);\n    } finally {\n      setIsRequestInProgress(false);\n    }\n  }, [selectedObject, objectCount, detectionMode, saveImageFunction]); // 촬영 간격에 따른 이미지 전송 간격 설정\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      sendImageToServer();\n    }, shootingInterval * 1000);\n    return () => clearInterval(interval);\n  }, [shootingInterval, sendImageToServer]); // 인터넷 연결 상태 감지 이벤트 설정\n\n  useEffect(() => {\n    window.addEventListener('online', () => setIsOnline(true));\n    window.addEventListener('offline', () => setIsOnline(false));\n    return () => {\n      window.removeEventListener('online', () => setIsOnline(true));\n      window.removeEventListener('offline', () => setIsOnline(false));\n    };\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      position: 'relative',\n      width: '100%',\n      maxWidth: '800px',\n      margin: '0 auto'\n    },\n    children: [/*#__PURE__*/_jsxDEV(Webcam, {\n      ref: webcamRef,\n      screenshotFormat: \"image/jpeg\",\n      style: {\n        width: '100%',\n        height: 'auto'\n      },\n      videoConstraints: {\n        deviceId: 0,\n        width: 800,\n        height: 600\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 92,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: 'absolute',\n        top: 10,\n        right: 10,\n        width: 30,\n        height: 30,\n        borderRadius: '50%',\n        backgroundColor: indicatorColor\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 98,\n      columnNumber: 13\n    }, this), !isOnline && /*#__PURE__*/_jsxDEV(\"p\", {\n      style: {\n        color: 'red',\n        textAlign: 'center'\n      },\n      children: \"No internet connection\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 99,\n      columnNumber: 27\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      style: {\n        textAlign: 'center'\n      },\n      children: [\"Detected \", selectedObject, \"s: \", detectedCount]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 100,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 91,\n    columnNumber: 9\n  }, this);\n}\n\n_s(WebcamApp, \"eDJe/jXnmK4u6lhaNShO0ItpOCk=\");\n\n_c = WebcamApp;\nexport default WebcamApp;\n\nvar _c;\n\n$RefreshReg$(_c, \"WebcamApp\");","map":{"version":3,"sources":["/Users/song-wonjeong/Desktop/react-python/workspace/src/components/Skills/index.js"],"names":["React","useRef","useEffect","useCallback","useState","Webcam","WebcamApp","selectedObject","objectCount","shootingInterval","detectionMode","webcamRef","indicatorColor","setIndicatorColor","isOnline","setIsOnline","navigator","onLine","detectedCount","setDetectedCount","isRequestInProgress","setIsRequestInProgress","saveImageFunction","link","document","createElement","href","current","getScreenshot","download","Date","now","click","sendImageToServer","imageSrc","formData","FormData","append","response","fetch","method","body","data","json","detectedObjects","detected_objects","objectOccurrences","filter","obj","length","error","console","interval","setInterval","clearInterval","window","addEventListener","removeEventListener","position","width","maxWidth","margin","height","deviceId","top","right","borderRadius","backgroundColor","color","textAlign"],"mappings":"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","sourcesContent":["import React, { useRef, useEffect, useCallback, useState } from 'react';\nimport Webcam from 'react-webcam';\n\n// 웹캠 앱 컴포넌트\nfunction WebcamApp({ selectedObject, objectCount, shootingInterval, detectionMode }) {\n    // 웹캠 참조 설정\n    const webcamRef = useRef(null);\n    // 촬영 상태 표시 (빨간색: 촬영 중, 초록색: 촬영 완료)\n    const [indicatorColor, setIndicatorColor] = useState('red');\n    // 인터넷 연결 상태 확인\n    const [isOnline, setIsOnline] = useState(navigator.onLine);\n    // 감지된 객체 수\n    const [detectedCount, setDetectedCount] = useState(0);\n    // 서버 요청 진행 상태\n    const [isRequestInProgress, setIsRequestInProgress] = useState(false);\n\n    // 이미지 저장 함수\n    const saveImageFunction = useCallback(() => {\n        const link = document.createElement('a');\n        link.href = webcamRef.current.getScreenshot();\n        link.download = `capture_${Date.now()}.jpg`;\n        link.click();\n    }, [webcamRef]);\n\n    // 서버에 이미지 전송 및 객체 감지 함수\n    const sendImageToServer = useCallback(async () => {\n        if (!webcamRef.current || isRequestInProgress) {\n            return;\n        }\n\n        const imageSrc = webcamRef.current.getScreenshot();\n        if (!imageSrc) {\n            return;\n        }\n\n        setIsRequestInProgress(true);\n\n        const formData = new FormData();\n        formData.append('image', imageSrc);\n\n        try {\n            let response = await fetch(\"http://localhost:8000/detect\", {\n                method: \"POST\",\n                body: formData\n            });\n            let data = await response.json();\n            const detectedObjects = data.detected_objects;\n            const objectOccurrences = detectedObjects.filter(obj => obj === selectedObject).length;\n            setDetectedCount(objectOccurrences);\n\n            // 감지 모드에 따른 이미지 저장 조건\n            if (detectionMode === \"above\" && objectOccurrences >= objectCount) {\n                saveImageFunction();\n                setIndicatorColor('green');\n            } else if (detectionMode === \"below\" && objectOccurrences <= objectCount) {\n                saveImageFunction();\n                setIndicatorColor('green');\n            } else if (detectionMode === \"fix\" && objectOccurrences === objectCount) {\n                saveImageFunction();\n                setIndicatorColor('green');\n            } else {\n                setIndicatorColor('red');\n            }\n        } catch (error) {\n            console.error(\"Error sending image to server: \", error);\n        } finally {\n            setIsRequestInProgress(false);\n        }\n    }, [selectedObject, objectCount, detectionMode, saveImageFunction]);\n\n    // 촬영 간격에 따른 이미지 전송 간격 설정\n    useEffect(() => {\n        const interval = setInterval(() => {\n            sendImageToServer();\n        }, shootingInterval * 1000);\n\n        return () => clearInterval(interval);\n    }, [shootingInterval, sendImageToServer]);\n\n    // 인터넷 연결 상태 감지 이벤트 설정\n    useEffect(() => {\n        window.addEventListener('online', () => setIsOnline(true));\n        window.addEventListener('offline', () => setIsOnline(false));\n        return () => {\n            window.removeEventListener('online', () => setIsOnline(true));\n            window.removeEventListener('offline', () => setIsOnline(false));\n        };\n    }, []);\n\n    return (\n        <div style={{ position: 'relative', width: '100%', maxWidth: '800px', margin: '0 auto' }}>\n            <Webcam \n                ref={webcamRef} \n                screenshotFormat=\"image/jpeg\"\n                style={{ width: '100%', height: 'auto' }}\n                videoConstraints={{ deviceId: 0, width: 800, height: 600 }}\n            />\n            <div style={{ position: 'absolute', top: 10, right: 10, width: 30, height: 30, borderRadius: '50%', backgroundColor: indicatorColor }}></div>\n            {!isOnline && <p style={{ color: 'red', textAlign: 'center' }}>No internet connection</p>}\n            <p style={{ textAlign: 'center' }}>Detected {selectedObject}s: {detectedCount}</p>\n        </div>\n    );\n}\n\nexport default WebcamApp;\n"]},"metadata":{},"sourceType":"module"}